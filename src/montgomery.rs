use std::fmt;
use std::fmt::Debug;

use crypto_bigint::{Encoding, Random, subtle::Choice, U512, Zero};
use rand::thread_rng;
use rug::Integer;
use rug::integer::Order;

use crate::constants::{ModP, P_GMP};

#[derive(Clone, Debug, PartialEq)]
pub struct Point {
    pub x: ModP,
    pub z: ModP,
}

impl Point {
    pub const fn from_x(x: ModP) -> Point {
        Point { x, z: ModP::ONE }
    }

    pub const fn zero() -> Point {
        Point {
            x: ModP::ONE,
            z: ModP::ZERO,
        }
    }

    pub fn random() -> Point {
        Point::from_x(ModP::random(&mut thread_rng()))
    }

    pub fn is_zero(&self) -> Choice {
        self.z.is_zero()
    }

    pub fn normalize(&self) -> Point {
        let (z_inv, is_nonzero) = self.z.invert();
        if bool::from(is_nonzero) {
            Point {
                x: self.x * z_inv,
                z: ModP::ONE,
            }
        } else {
            Point {
                x: ModP::ONE,
                z: ModP::ZERO,
            }
        }
    }

    pub fn nonzero_to_bytes(&self) -> Option<[u8; 64]> {
        if bool::from(self.is_zero()) {
            return None;
        }
        Some(self.x.retrieve().to_be_bytes())
    }
}

impl fmt::Display for Point {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        let p = self.normalize();
        write!(f, "{} : {}", p.x.retrieve(), p.z.retrieve())
    }
}

#[derive(Debug, PartialEq, Clone)]
pub struct MontgomeryCurve {
    pub a: Point, // projective coefficient, A = a.x/a.z
}

impl MontgomeryCurve {
    pub const fn new(a: ModP) -> MontgomeryCurve {
        MontgomeryCurve {
            a: Point::from_x(a),
        }
    }

    const fn projective(ax: ModP, az: ModP) -> MontgomeryCurve {
        MontgomeryCurve {
            a: Point { x: ax, z: az },
        }
    }

    pub fn twist(&self) -> MontgomeryCurve {
        MontgomeryCurve::new(self.a.x.neg())
    }

    pub fn normalize(&self) -> MontgomeryCurve {
        let a = self.a.normalize();
        MontgomeryCurve { a }
    }

    // Whether p corresponds to any rational point on the curve
    pub fn on_curve(&self, p: &Point) -> bool {
        let sq = p.x.square();
        let x3 = sq * p.x; // cube of p.x
        let x2 = sq * self.a.x;
        let rhs = x3 + x2 + p.x;
        // If rhs is square, point is only rational on this curve
        // If rhs is zero, point is rational on both curve and twist
        // If rhs is non-square, point is only rational on the twist
        //TODO: CT?
        let l = Integer::from_digits(
            &rhs.as_montgomery().as_limbs().map(|x| x.0.to_le()),
            Order::LsfLe,
        )
        .legendre(&P_GMP);
        // let l = jacobi_vartime(&rhs);
        l != -1
    }

    // Given points P, Q, and either P+Q or P-Q, computes P-Q or P+Q
    // P, Q must be distinct points, neither of which are the origin or infinity (zero)
    // Algorithm 1 in Costello & Smith
    fn add3(&self, p: &Point, q: &Point, pq: &Point) -> Point {
        let v1 = (p.x + p.z) * (q.x - q.z);
        let v2 = (p.x - p.z) * (q.x + q.z);
        let v3 = (v1 + v2).square();
        let v4 = (v1 - v2).square();
        Point {
            x: pq.z * v3,
            z: pq.x * v4,
        }
    }

    // Given P not equal to origin or infinity, computes P+P
    // Projective version of Algorithm 2 in Costello & Smith,
    // obtained by multiplying through by 4a.z
    fn double(&self, p: &Point) -> Point {
        // V1 in Costello & Smith
        let vplus = (p.x + p.z).square(); // (x + z)^2

        // V2 in Costello & Smith
        let vminus = (p.x - p.z).square(); // (x - z)^2

        let vdelta = vplus - vminus; // V1 in Costello & Smith
        let va = vminus * self.a.z;
        let va = va + va + va + va;

        let x = vplus * va; // vminus * vplus * denominator

        let vb = (self.a.z + self.a.z + self.a.x) * vdelta + va;

        Point { x, z: vb * vdelta }
    }

    // Given P not equal to origin or infinity, computes x([k]P)
    // Algorithm 4 in Costello & Smith, Montgomery ladder
    pub fn mult(&self, p: &Point, k: &ModP) -> Point {
        let k = k.retrieve();
        if bool::from(k.is_zero()) {
            return Point::zero();
        } else if k == U512::ONE {
            return p.clone();
        }
        let ell = k.bits() - 2;
        let mut x0 = p.clone();
        let mut x1 = self.double(p);

        // standard double-and-add, but adapted to x-only arithmetic
        for i in (0..=ell).rev() {
            let sum = self.add3(&x0, &x1, p);
            //TODO: CT?
            if bool::from(k.bit(i)) {
                x0 = sum;
                x1 = self.double(&x1);
            } else {
                x1 = sum;
                x0 = self.double(&x0);
            }
        }

        Point { x: x0.x, z: x0.z }
    }

    // Computes isogeny phi with kernel generated by point k, with order ell
    // Returns codomain curve of isogeny and image of point p under the isogeny
    // Algorithm from Castryck et al.
    pub fn isogeny(&self, k: &Point, ell: usize, p: &Point) -> (Point, MontgomeryCurve) {
        assert!(ell > 2);
        assert_eq!(ell % 2, 1);

        // inititalize computation of q = phi(p)
        let mut q = Point {
            x: ModP::ONE,
            z: ModP::ONE,
        };

        // shared factors for coefficient c computation
        let psub: ModP = p.x - p.z;
        let padd: ModP = p.x + p.z;

        // last three multiples of kernel generator k, kernel_points[i % 3] = [i+1]k
        let mut kernel_points: [Point; 3] = [k.clone(), self.double(k), Point::zero()];
        // let (x_i : z_i) = [i]k, and expand the product (z_i*w + x_i) as poly of w
        // c = [c_0, c_1, c_(ell-2), c_(ell-1)] are first two, last two coefficients of this expansion
        let mut c: [ModP; 4] = [ModP::ONE, ModP::ZERO, ModP::ZERO, ModP::ONE];

        // Since [i]P = [ell-i]P, we only compute up to ell/2 and then square the products
        for i in 0..(ell / 2) {
            if i > 1 {
                // [i]k = [i-1]k + k
                kernel_points[i % 3] =
                    self.add3(&kernel_points[(i - 1) % 3], k, &kernel_points[(i - 2) % 3]);
            }

            // Xi/Zi = [i+1]P
            let xi: &ModP = &kernel_points[i % 3].x;
            let zi: &ModP = &kernel_points[i % 3].z;

            // multiply polynomial by (Zi*w + Xi)
            let a = c[0] * zi;
            let b = c[1] * xi;
            c[1] = a + b;
            c[0] *= xi;

            let a = c[2] * zi;
            let b = c[3] * xi;
            c[2] = a + b;
            c[3] *= zi;

            // Inner portion of equation 17 in Costello & Hisil, computes:
            // a = (X-Z)*(Xi+Zi), b = (X+Z)*(Xi-Zi)
            // Q.x *= (a + b)
            // Q.z *= (a - b)
            let ikadd = xi + zi;
            let iksub = xi - zi;
            let a = psub * ikadd;
            let b = padd * iksub;
            let s = a + b;
            let t = a - b;

            q.x *= s;
            q.z *= t;
        }

        // Compute Q = phi(P) via Equation 17 from Costello & Hisil
        q.x = p.x * q.x.square();
        q.z = p.z * q.z.square();

        // square the polynomial
        c[1] *= c[0];
        c[1] += c[1];
        c[0] = c[0].square();

        c[2] *= c[3];
        c[2] += c[2];
        c[3] = c[3].square();

        // Codomain coefficient formula from Castryck et al.
        // A'.x = A.x*c[0]*c[ell-1] - A.z*3*(c[0]*c[ell-2] - c[1]*c[ell-1])
        // A'.z = A.z*c[ell-1]^2
        let a = self.a.x * c[0] * c[3];
        let b = (c[0] * c[2]) - (c[1] * c[3]);
        let b = self.a.z * b;
        let b3 = b + b + b;

        let ax = a - b3;
        let az = self.a.z * c[3].square();
        let codomain = MontgomeryCurve::projective(ax, az);
        (q, codomain)
    }

    pub fn to_bytes(&self) -> Option<[u8; 64]> {
        self.a.nonzero_to_bytes()
    }

    pub fn from_be_slice(a: &[u8]) -> MontgomeryCurve {
        MontgomeryCurve::new(ModP::new(&U512::from_be_slice(a)))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn on_curve() {
        let a = ModP::new(&U512::from_be_hex("57164DAD2DAA6B17538CC28E418D0B93540024EC5F7038951049142A2FA46F030D7E5247B792A894FF526D7126DCB9CDEF42704493B6F8109CC5B127FD6F4888"));
        let e = MontgomeryCurve::new(a);

        let p = Point::from_x(ModP::new(&U512::from_be_hex("39F65EDE480BF8C5E5ACA9CE8EAC7EC98B8C02E3768B83444D77F06961B50B9CDCD8A3644D244624766ABECED59F881BA06B04033B6FA7652396BA8798A16CEA")));
        assert!(e.on_curve(&p));

        let p = Point::from_x(ModP::new(&U512::from_be_hex("4ACCB8B58B35F4D9787314CB062D264A5CD43EC672B48CEAD6FE63FD49A94CC36912F751EAE0D262F1584DA663F2A3A18506EF9F4B444D7F40AAC0A7E5838869")));
        assert!(e.on_curve(&p));

        let p = Point::from_x(ModP::new(&U512::from_be_hex("5727FDAA0E1070CFF054606C531F4BE7B6D55B9B2CC2F343C19306C76BFA01D247BBDC9F05E5AFD1D08453C532F1E733CC3419C868167AF4F03AC860A90E258F")));
        assert!(!e.on_curve(&p));

        let p = Point::from_x(ModP::new(&U512::from_be_hex("63576655EC3AA520BF7A2B022D5253C18E8676C03EF81FA05030B2A4509F2E4C11A37DDDB06606A6CA94DAD30DD0876E300FD9AEAEF2B075DD5CE6AD74255B13")));
        assert!(!e.on_curve(&p));
    }

    #[test]
    fn add3() {
        let m = ModP::new(&U512::from_be_hex("54C8A0DADC3C7B204FDF48616AF757968326DC25866F018424FCD27D45C809CAC0D3F58553D6CB42704819843C67406977C51CD790BE78350FADAB6CB72AFA8D"));
        let mut e = MontgomeryCurve::new(ModP::ZERO);
        e.a.x *= m;
        e.a.z *= m;

        let p = Point::from_x(ModP::new(&U512::from_be_hex("2C269236F8C147E177F0A3B5C95EA91A4C04DE1BBA1FFC84622CE367805C8551A7D628FFEA33900BA7F6F90F65AA0EAFEA189CEC225A1730B7F1E28FF2C253B4")));
        let q = Point::from_x(ModP::new(&U512::from_be_hex("258DD34D9A793CE8396185303C65012683D12744E672B2195B38D7A2DF26242024C3E8740CCAFD3071388C488266E2BBCBA9F5B3F2D4252CBCDB4EF69DD58EDB")));
        let pq_sum = Point::from_x(ModP::new(&U512::from_be_hex("55DA2197E667E35145692AB34A06D9C62A379533C8430B98295F3F0A6828682BC7046F3DF84760F6C22CBBEA55B67EF83C53AB1CF103DE0CF0774719D9038C46")));
        let pq_diff = Point::from_x(ModP::new(&U512::from_be_hex("5A54CDD887887905BB57A2FB2C5D108A361052CAF9B80E93812C69E5BF5EA6C9869F43748FB12937C5A91C999AAF4A5D0CBA6A0B9B67A8339F15DA786626F7F3")));

        assert_eq!(e.add3(&p, &q, &pq_sum).normalize(), pq_diff);
        assert_eq!(e.add3(&p, &q, &pq_diff).normalize(), pq_sum);

        let a = ModP::new(&U512::from_be_hex("47D112C8D0BBF39D1983F677BE0CD423445C8BACA91B516EB3350F1CB95FFB454F4B0C18CE2EA540CE7B0932B951B365511CDBB82458DCA4D0ABBA04DB00D84D"));
        let m = ModP::new(&U512::from_be_hex("52C521933A01AD67352ABAEE2BB6FDB4025BA653A1B6C5C8B939B5647EF56A8111640A7717FEEB38967FE1F7B653384D1E4C5E4DAA76686F97CA4DC9E405C543"));
        let mut e = MontgomeryCurve::new(a);
        e.a.x *= m;
        e.a.z *= m;

        let p = Point::from_x(ModP::new(&U512::from_be_hex("55D5F791250BF6F55EF6DCDE2F1249DB59DAEA4FDAB940A53FC796293B137D58FC0888CF466C523C21EED52CDA1554705E3ECE421FDB0653E052DE3009F60C29")));
        let q = Point::from_x(ModP::new(&U512::from_be_hex("38AC0C3673F3DE0E5C049EA68C97CE5261EEE5EC6BB02F568E0D3B70A40E139F22C64995A40B1B5F90D3AFF943557C0E14BB8227C477FC7E822C5787450198DB")));
        let pq_sum = Point::from_x(ModP::new(&U512::from_be_hex("5C58A818F02D09EF5DC1CAABEC133D07D3D9EFB98984B1DD9B7636D4A4FBC6B47FBF51FCDB71570CE00C723F4083CF4E70F1467077FC99B0AB746004ECC445BD")));
        let pq_diff = Point::from_x(ModP::new(&U512::from_be_hex("174B7233B392E09C38F7DB5DA5D352585FBE4D16CBD626404D894CA3407AB399400FD9FFE0FDF1C76ADB7F11955F88F45805EBDD727271F5465BEB39D96E6782")));

        assert_eq!(e.add3(&p, &q, &pq_sum).normalize(), pq_diff);
        assert_eq!(e.add3(&p, &q, &pq_diff).normalize(), pq_sum);
    }

    #[test]
    fn double() {
        let m = ModP::new(&U512::from_be_hex("09F4B54FF7BCF319672BEDF8D865F241C27D52BE5D70F8E4BD18806AF9E5BFF3FC85635574EC6D8513679E8F1BBE290672AC5AB4A0106D05C10DD74B758F2589"));
        let mut e = MontgomeryCurve::new(ModP::ZERO);
        e.a.x *= m;
        e.a.z *= m;

        let p = Point::from_x(ModP::new(&U512::from_be_hex("24FECD3460B2F53C30EC39BE2E4CE435EAC8EE1E5E57CC2A022D9C885F941346D78DFA27AF0BE7CBFE913E461310BB5713A85D7AC02AAD5B8E802D2F7D045199")));
        let q = Point::from_x(ModP::new(&U512::from_be_hex("50809AE8A1F22F00D2D655E4E6E7580A1C868E59AE4BE4E98A7AF3FD3BB0A26C24724B6E0C98EFA529C914E7F5DFA89D1CBBCEF8E2DB859AB9538A7787B10EFB")));
        let two_p = Point::from_x(ModP::new(&U512::from_be_hex("08D21FCB978BE16F2A6A9A5753418098BE7CE928B417E4672B448F99029BF4F9D771C6AE5356889A0A7F0DD30AC467343CEDFD25BDE221C8B82B9D208CB3F2C1")));
        let two_q = Point::from_x(ModP::new(&U512::from_be_hex("02C862DCE53D5BE8C3FDDBC31152CAF717D52579033EF877E8DCAD1BF333C3B590D045023BD3B365D0FB0EDDAFB2D74871BA618EAB37C285B91CD83CF395F848")));

        assert_eq!(e.double(&p).normalize(), two_p);
        assert_eq!(e.double(&q).normalize(), two_q);

        let a = ModP::new(&U512::from_be_hex("20A24B2BE41B432B63B7C485E95F781E344744881BB3C9C36A10995DFB62592FFFDF6EAEA75F632894CC2D30F0C273AF4002D580E272FC2B4EB2C46730A6D7CD"));
        let m = ModP::new(&U512::from_be_hex("3DB6207324441ECC3884C3865E972993CA0C239CAABDC1E4BFEB70E73CA776A83C8AF9E383B93CEDE3E6BA05503D422EEE7FAA5484F4711E69939FA3FDF7DD97"));
        let mut e = MontgomeryCurve::new(a);
        e.a.x *= m;
        e.a.z *= m;

        let p = Point::from_x(ModP::new(&U512::from_be_hex("228B3C1B541F1C50E6E46545E9E3E26F747EC6D18D436CD02DA23B8AF7A37FD81F1132833AC5F96EBD3AF861F2CD83EAF429017B859EB55D6A7BAF514849B1BB")));
        let q = Point::from_x(ModP::new(&U512::from_be_hex("3F53508C3824E5B18630C63E35FD312E39B36345E7BA855D1AE5DA044682327A8FBE7627C46E707CD4E5F87BD0EB191D366DC0A7D7F2ECDFC7E6F9ECFC6A55D2")));
        let two_p = Point::from_x(ModP::new(&U512::from_be_hex("29306C62A1CFDDDEFE22DB90F5C3BF81DDA85BF6F25B45F37D6ECA62D633066CE47D707B9698EED38F1C2FD9D60E13EF33B712603FEE555A2EEFF68177B50A47")));
        let two_q = Point::from_x(ModP::new(&U512::from_be_hex("0E417B11BA938C20C957E22F787757DD7B138C633DF90F529DD0EC490A7FA49E847644AE5728E981DDCFC24D37B93EF169502C66FDBDE16D6D0A986DB0640738")));

        assert_eq!(e.double(&p).normalize(), two_p);
        assert_eq!(e.double(&q).normalize(), two_q);
    }

    #[test]
    fn mult() {
        let a = ModP::new(&U512::from_be_hex("0F65404A8762A1310462B75091BC880B90F5CC563F59FBC0895112E35F27E6DE9FBC44F95037C11D1C380BB6FBA089A3ABE20A6B2A89332BAF14CE916900268E"));
        let m = ModP::new(&U512::from_be_hex("2CC1305DAF90CF3849C4AE87B8C5F969ABDA84BDCF9356019318433CD87AA3F0BAC9455F2E2E6B233D78A6ADB31C2D233AE4818F34C837A4BE7B63570180714C"));
        let mut e = MontgomeryCurve::new(a);
        e.a.x *= m;
        e.a.z *= m;

        let p = Point::from_x(ModP::new(&U512::from_be_hex("1D5FEE8C54EAE6791B020BDE73090A0CDE5AAF6472F6C251C3BB46EA2DADC6E412CFE135AA6B65E11D1AB4B9F612918D2C050B6C105708BC2814A41BB71A1314")));
        let q = Point::from_x(ModP::new(&U512::from_be_hex("638D2CC4889113F79C022F08BC6EAD9A95EBD83CFD914BE639E2E6CCDB70FC6876CB9DFF05AC06698FE172B327C59FA605645B47D07BB15EFA2F7247A03EE84B")));

        let k = ModP::ZERO;
        assert_eq!(e.mult(&p, &k).normalize(), Point::zero());
        assert_eq!(e.mult(&q, &k).normalize(), Point::zero());

        let k = ModP::ONE;
        assert_eq!(e.mult(&p, &k).normalize(), p);
        assert_eq!(e.mult(&q, &k).normalize(), q);

        let k = ModP::new(&U512::from_be_hex("1AFD4893406045345813F35A4E8519DF1D126D6B0FA04259312890AC1011592DC33B75EC8F3427C5BF620F095A06E0E28557389CA1AE41DC6D671D256E132924"));
        let kp = Point::from_x(ModP::new(&U512::from_be_hex("36C63051A245BEAF9C715197C7EB37C9F199ECB72C5ADE3376E0290E8E95E2AF477B8CDC2588DB041B8FD455B62FB2B26CC066B6EE85072F0BA1F57CCE119979")));
        let kq = Point::from_x(ModP::new(&U512::from_be_hex("4105472DBE22538577C4144B0DFBA98977F74DF8EC235E5876484803ED8C4C34CB72534E834AB72D86138A1F5B01A006DF1AAA6030834403B811D2F6FF74BEB7")));
        assert_eq!(e.mult(&p, &k).normalize(), kp);
        assert_eq!(e.mult(&q, &k).normalize(), kq);

        let k = ModP::new(&U512::from_be_hex("0D4B1AEE28AB783B589255E0C0B6983DE8F5B3ACEE733C36B9A8B7B362A3AE94B0BB71595D324F8065A3B32A81E3DCD5FC26CB02CA763ABF7CCAD55F96DB11EC"));
        let kp = Point::from_x(ModP::new(&U512::from_be_hex("145730A5A88421AFFD62098BAE43D698E269F011D926BB37060F2699D367CDD0213664632B963EEEB649F31B2394C3E0B1264EC021CD62215234F1A6DACF4634")));
        let kq = Point::from_x(ModP::new(&U512::from_be_hex("3F18A2D2C8814FD94B1AF5888073F4BE0EDBF19E11A86F953FFC8C20A028CBA6E6E7201CB9277A950EEB8543D05D758B6CC1F425C4BAB16963E813D095121E49")));
        assert_eq!(e.mult(&p, &k).normalize(), kp);
        assert_eq!(e.mult(&q, &k).normalize(), kq);
    }

    #[test]
    fn isogeny() {
        let a = ModP::ZERO;
        let b = ModP::new(&U512::from_be_hex("53BAA451F759835A01933C76BC58C0C203A9B6B02F7F086B30C3469A8452750AAECA8A4F7C26BFF43876F4510F405F4D2A006635D89A42D327D9A2E8C00BF340"));
        let order: usize = 3usize;

        let k = Point::from_x(ModP::new(&U512::from_be_hex("22B668C942BF7D5F5DF869A215F7E9463A0A873CFE2953721F129EC98B8123A8E62DF0D1F100AA92F4C6C8552AD62C42C11DB1AE8540F46ADC16D8939808553A")));
        let p = Point::from_x(ModP::new(&U512::from_be_hex("0A3A72458C434F22FD1F2B441C3BAD38C0C069872F69372A43E818126CFF49DC3CA63E87BC5F0443201F9DA03EFE8DA618C4D207954D40F774A923CBC11F2CA7")));
        let im_p = Point::from_x(ModP::new(&U512::from_be_hex("1ED168610F98DC95AAB55E2B067E92B32AF0A436A73EF7142F31BC3CBE2A532F8D51061DA110C5EB01FEC1838C6D0AA3B643D90181AAA3184CF02ABB20ECFB2A")));

        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = ModP::new(&U512::from_be_hex("48211766D23E629D22C38ED44B3D8A02622B7022E5CE2CE5CCF7CDD4F901213AE61B00371E74AD24C9F71C59C0B0269287B36EC9652F4ACC421B8975C8C9EE4F"));
        let b = ModP::new(&U512::from_be_hex("20B68C844B20BBA2271497C8ECD471D2EB0E3640A3D238F142C13C3C86BDF9D2F758186586740B2A15F9709E18F93F7894704B23CCBB533AC8AD2F1031AE309B"));
        let order: usize = 5usize;
        let k = Point::from_x(ModP::new(&U512::from_be_hex("409548FAF7B5117391A5AD4D1202CA9EE096D69F44188441796F2ACED23C0C21DA29C9286AD5A46636CE1E41F9F54CEF4F453F7EFFCD595E168CC519DD68EA51")));
        let p = Point::from_x(ModP::new(&U512::from_be_hex("3B2DC0FD5EE8C65F43DAD597D8C48C32138A9FE4A1008802D5CED33523731EB432469E2D7F2276625E3DF38566576180E559E1C13D5F9565696A6D0D83830FF4")));
        let im_p = Point::from_x(ModP::new(&U512::from_be_hex("3BF01DE995EB675B0C2303367BC0FC3F82AC3D7123F842DEC8DE1E34F6FE14FBFDC1BDF203914BF7F6C52A7AF66CA745D4C682A4D1C9F40D1D5CFB066BB46B2D")));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = ModP::new(&U512::from_be_hex("48912381B13014DF7E10F242424DFE6D43860ED48A2913843A45E75E15615849B2E2C8191E6CEF70A931E20883E8B59B87046926B8E534DCA88722A8E204496C"));
        let b = ModP::new(&U512::from_be_hex("4E7D723C463A2F779721CD1F53CB1F2F3F9ECEB60E1831A2DDC665687C1F7BD1B479670592F4967DFAD3F9675B6229ED2B4ECFC2AAE33258DAF6A1B5CCBF2B78"));
        let order: usize = 173usize;
        let k = Point::from_x(ModP::new(&U512::from_be_hex("54C8CDA4F5B40B4DD5EF9011AFA313195A68106114B157B53270CB1005C8338E4CE00C826ECEE406027F383FA1D5037DBB81D92E4203B4092B9C3D20A32D49A8")));
        let p = Point::from_x(ModP::new(&U512::from_be_hex("55E59A6BB770F1477F38E747D4C45F61CDA4D068736398DCB7C3A6B872208E6BA55FA42377A4B3EB25AEF4D0CE59C91A1D3A291B87700FFFE21805A7DEED199B")));
        let im_p = Point::from_x(ModP::new(&U512::from_be_hex("5BBC4E76109DAF1BCC7A597C78DCA56C1645CA6C72859B3F316F972054BF200C0F8059E2CCD9B1886F7518230CC5A75E210A3A5C07D843FF79BD832B675E1BD3")));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = ModP::new(&U512::from_be_hex("4F80CF43DC32028D21AF9A4596C7067352C764156B62056D1DBC2A528E367DAC0BC65E453F01864DF53E0A775E064988EDD71034EBE1D5B95C1235F11DC6ACFD"));
        let b = ModP::new(&U512::from_be_hex("1AFAA394A786BAEB11895EE8A455AE6A6872C74C9D2F0F47773AAB2FD1481BACC7695E7B81177C643C054D3BD36268F5ABD7AE225EEBEFA531F9153F532E4BA5"));
        let order: usize = 83usize;
        let k = Point::from_x(ModP::new(&U512::from_be_hex("425A0D7407BF49078B071367E138506CDF3CF5C5231384524F9C62C7E84BF1536C47B5AC7B981BD1D8B8A4FF5ED0A75471F0D80ED1515CE18C2D31780929FD58")));
        let p = Point::from_x(ModP::new(&U512::from_be_hex("1C33BAADF7E34ACA1AFE98CEF02BA3948B0A09A2996BC9BC2C28A4E33A4943E8FA63370DF59C0CDA3C1D943473E50B2D4334DEE8263F6CF6450619460BF09DC4")));
        let im_p = Point::from_x(ModP::new(&U512::from_be_hex("46C02021FCC07A06A4C41958C3C40EB31DF7D10947C1021FE2638A9DADB7C8792D8EC0271FE63DFDE0BF6E1B4D44E550A9606DC91541DC15263292469892BD8D")));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);

        let a = ModP::new(&U512::from_be_hex("38C29C0734D6DD3278A7DCDB797A4D8D1E6C41ADAC0FA768EE3BF9EE8FBC3EECE077F09DE1644631226B822B3BA01868DE4A9E7603DADA2D024BB5B16E083020"));
        let b = ModP::new(&U512::from_be_hex("2FDC10B37A9570DFA25AEE9482802ECDC60E7D5D47B6E06AC5C3114BA70DDF38C6D820DFAD5A126794DC0CCF78A3BB91283DEAE9D6B540EB45506934D5C145B7"));
        let order: usize = 149usize;
        let k = Point::from_x(ModP::new(&U512::from_be_hex("5E9D1A6638D9610AE0568BC36A483E512E3AC582C45E79A5388D0C213F7315052B4B74784F468E9D5CE9EA882D9511AF4A7B92E7CDEC4D5AE22D32D8B9F805DE")));
        let p = Point::from_x(ModP::new(&U512::from_be_hex("35EE2441FB15C6C330837FA2950A9860C33A14E6847D78DE6EB62FF85291477CEB7E69CE825B88637283A87379AC17D3A1E319A2D95172CFFC31FE6380C54749")));
        let im_p = Point::from_x(ModP::new(&U512::from_be_hex("3A12C8F02C85892393291F5860DB7B8C86C198FE89B44B165A91E9C05F185896C036B64331A418347706C6D124B73AECE248925112F207E3E53114FEECE14545")));
        let ea = MontgomeryCurve::new(a);

        let (xp, xb) = ea.isogeny(&k, order, &p);
        let xb = MontgomeryCurve::new(xb.a.normalize().x);
        assert_eq!(xb.a.x, b);
        assert_eq!(im_p.normalize().x, xp.normalize().x);
    }
}
